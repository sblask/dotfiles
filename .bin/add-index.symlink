#!/usr/bin/env python
# pylint: disable=invalid-name
import argparse
import re
import sys

ANSI_REGEXP = re.compile(
    r'\x1b[^m]+m'
)
GIT_BRANCH_REGEXP = re.compile(
    r'(?P<prefix>\*? +)'
    r'(?P<indexable>.+)'
)
GIT_STATUS_REGEXP = re.compile(
    r'(?P<prefix>\t(\x1b[^m]+m)?([^:]+: +)?)'
    r'(?P<indexable>.+)'
)
LS_REGEXP = re.compile(
    r'(?P<prefix>([0-9]+ )?([^ ]+ +){8})'
    r'(?P<indexable>.+)'
)

SUPPORTED_INPUT_TYPES = (
    'git_branch',
    'git_status',
    'ls_list',
)


def get_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--input-type',
        required=True,
        choices=SUPPORTED_INPUT_TYPES,
    )
    parser.add_argument(
        '--print-indexables',
        action='store_true',
    )
    parser.add_argument(
        'infile',
        nargs='?',
        type=argparse.FileType('r'),
        default=sys.stdin,
    )
    parser.add_argument(
        'outfile',
        nargs='?',
        type=argparse.FileType('w'),
        default=sys.stdout,
    )
    return parser.parse_args()


def main():
    arguments = get_arguments()

    if arguments.input_type == 'git_branch':
        lines, indexables = parse_git_branch_input(arguments)
    elif arguments.input_type == 'git_status':
        lines, indexables = parse_git_status_input(arguments)
    elif arguments.input_type == 'ls_list':
        lines, indexables = parse_ls_list_input(arguments)

    print_output(arguments, lines, indexables)
    maybe_print_indexables(arguments, indexables)


def parse_git_branch_input(arguments):
    lines = []
    indexables = []

    for line in arguments.infile:
        match = GIT_BRANCH_REGEXP.match(line)
        if not match:
            lines.append((line, None))
        else:
            lines.append((match.group('prefix'), match.group('indexable')))
            indexables.append(match.group('indexable'))

    return lines, indexables


def parse_git_status_input(arguments):
    lines = []
    indexables = []

    for line in arguments.infile:
        match = GIT_STATUS_REGEXP.match(line)
        if not match:
            lines.append((line, None))
        else:
            lines.append((match.group('prefix'), match.group('indexable')))
            if 'renamed' in match.group('prefix'):
                indexables.append(match.group('indexable').split(' -> ')[1])
            else:
                indexables.append(match.group('indexable'))

    return lines, indexables


def parse_ls_list_input(arguments):
    lines = []
    indexables = []

    for line in arguments.infile:
        match = LS_REGEXP.match(line)
        if not match:
            lines.append((line, None))
        else:
            lines.append((match.group('prefix'), match.group('indexable')))
            indexables.append(match.group('indexable').split(' -> ')[0])

    return lines, indexables


def print_output(arguments, lines, indexables):
    outfile = arguments.outfile

    padding = len(str(len(indexables))) + 2
    index = 1
    for prefix, indexable in lines:
        if indexable is None:
            outfile.write(prefix)
        else:
            index_string = '[%s]' % index
            fixed_length_index_string = index_string.rjust(padding, ' ') + ' '
            outfile.write(prefix + fixed_length_index_string + indexable + '\n')
            index += 1


def maybe_print_indexables(arguments, indexables):
    outfile = arguments.outfile

    if arguments.print_indexables:
        outfile.write('@@indexables@@\n')
        for indexable in indexables:
            outfile.write(ANSI_REGEXP.sub('', indexable))
            outfile.write('\n')


if __name__ == '__main__':
    main()
